<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 骆二胖的博客</title>
    <link>http://lorcanluo.github.io/post/</link>
    <description>Recent content in Posts on 骆二胖的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Nov 2015 17:54:12 +0800</lastBuildDate>
    <atom:link href="http://lorcanluo.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>android6.0电源管理方式</title>
      <link>http://lorcanluo.github.io/post/android6.0%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 30 Nov 2015 17:54:12 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/android6.0%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</guid>
      <description>

&lt;p&gt;从Android 6.0开始，Android引入了两种电源优化特性来延长电源使用时间。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Doze：休眠状态&lt;/li&gt;
&lt;li&gt;App Standby：App 挂起&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;doze:ae9920511987a07389ba2d8a27b5e486&#34;&gt;Doze&lt;/h2&gt;

&lt;p&gt;如果用户手机未充电并且屏幕关闭一段时间以后，设备将进入休眠模式。在休眠状态下，系统将通过以下两种方式来节省电量：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;限制app访问网络&lt;/li&gt;
&lt;li&gt;限制大量占用Cpu的Service&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;并且阻止APP访问网络，推迟APP的任务，同步和标准闹钟。&lt;/p&gt;

&lt;p&gt;在该模式下，系统周期性的退出休眠状态一小段时间使得app能完成他们推迟的工作。见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lorcanluo/myHugoProject/master/myImage/optimizeUi/doze.png&#34; alt=&#34;doze&#34; /&gt;&lt;/p&gt;

&lt;p&gt;见上图，系统周期的退出Doze模式，来呼起延迟的操作.
当用户移动设备，打开屏幕或则连接电源唤醒设备以后，系统将退出休眠模式并且所有app将会进入正常活动状态。&lt;/p&gt;

&lt;h3 id=&#34;doze-restrictions:ae9920511987a07389ba2d8a27b5e486&#34;&gt;Doze restrictions&lt;/h3&gt;

&lt;p&gt;休眠模式下，将会限制以下你的app操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网络访问将会挂起&lt;/li&gt;
&lt;li&gt;系统将会忽略 wake lock&lt;/li&gt;
&lt;li&gt;标准的AlarmManager(setExact()和setWindow（））)将会推迟到下一个maintenance window.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你在休眠状态下需要alarms 可以使用setAndAllowWhileIdle()或则setExactAndAllowWhileIdel（）方法。&lt;/p&gt;

&lt;p&gt;用setAlarmClock()的闹钟不受影响-系统会短暂的退出休眠模式来唤起这个闹钟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;系统不再扫描Wi_Fi&lt;/li&gt;
&lt;li&gt;系统不允许sync adapter运行&lt;/li&gt;
&lt;li&gt;系统不允许JobScheduler运行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;适配你的app到doze状态:ae9920511987a07389ba2d8a27b5e486&#34;&gt;适配你的app到Doze状态&lt;/h3&gt;

&lt;p&gt;取决于你用的特性和服务，Doze对App的影响是不同的，如果你用了上述的一些功能，那么你需要调整你得App。&lt;/p&gt;

&lt;p&gt;对使用AlarmManager的App，6.0引入了两个新的方法：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;setAndAllowWhileIdle()&lt;/p&gt;

&lt;p&gt;setExactAndAllowWhileIdle().&lt;/p&gt;

&lt;p&gt;但是就算加了这两个方法,每15分钟闹钟服务只能允许呼起一次&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么对于我们这种实时消息（IM）开发的将是一个噩耗，那么Google推荐的方式是使用&lt;strong&gt;GCM&lt;/strong&gt; ，我们木有啊，木有啊，所以我觉得6.0在国内暂时还需要一段时间。&lt;/p&gt;

&lt;h2 id=&#34;app-standby:ae9920511987a07389ba2d8a27b5e486&#34;&gt;App Standby&lt;/h2&gt;

&lt;p&gt;当用户没有和一个App交互的时候，系统将会决定这个app是否是非活跃状态，这就是App Standby.当用户一段时间内没有点击app并且没有以下的这些条件的时候，系统将会决定是否进入挂起状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户显示的启动了app&lt;/li&gt;
&lt;li&gt;app当前在前台有任务在处理&lt;/li&gt;
&lt;li&gt;app产生了一条通知&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当用户插上电源以后，系统将会释放app的挂起状态，这时候允许app自由的访问网络，执行等待的jobs和syncs。如果设备长时间处于非活跃状态，系统只允许这些app一天访问一次网络。&lt;/p&gt;

&lt;h3 id=&#34;所以我们只能使用gcm有木有-有木有-国内木有有木有-咋个办-我还不知道:ae9920511987a07389ba2d8a27b5e486&#34;&gt;所以我们只能使用GCM有木有？有木有？国内木有有木有？咋个办？我还不知道&amp;hellip;..&lt;/h3&gt;

&lt;p&gt;这个问题只能等待国内厂商解决了!&lt;/p&gt;

&lt;h3 id=&#34;白名单:ae9920511987a07389ba2d8a27b5e486&#34;&gt;白名单&lt;/h3&gt;

&lt;p&gt;用户可以在电源管理里面把app加入白名单。&lt;/p&gt;

&lt;h2 id=&#34;模拟doze状态测试app:ae9920511987a07389ba2d8a27b5e486&#34;&gt;模拟Doze状态测试app&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;找一个6.0以上的手机或则虚拟机&lt;/li&gt;
&lt;li&gt;连接设备到你的开发机并安装你的应用&lt;/li&gt;
&lt;li&gt;打开你得应用&lt;/li&gt;
&lt;li&gt;关掉屏幕（app还处于活跃状态）&lt;/li&gt;
&lt;li&gt;运行以下命令强制系统进入Doze状态&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;   $ adb shell dumpsys battery unplug
   $ adb shell dumpsys deviceidle step
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能需要运行第二行命令多次，重复直至设备进入休眠状态&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;观察APP状态，然后填坑吧&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;模拟app-standby测试app:ae9920511987a07389ba2d8a27b5e486&#34;&gt;模拟app standby测试app&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;找一个6.0以上的手机或则虚拟机&lt;/li&gt;
&lt;li&gt;连接设备到你的开发机并安装你的应用&lt;/li&gt;
&lt;li&gt;打开你得应用&lt;/li&gt;
&lt;li&gt;运行以下命令强制系统进入app stanby状态&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;   $ adb shell dumpsys battery unplug
   $ adb shell am set-inactive &amp;lt;packageName&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;运行以下命令模拟唤醒你得app&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;   $ adb shell am set-inactive &amp;lt;packageName&amp;gt; false
   $ adb shell am get-inactive &amp;lt;packageName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;观察你得app，填坑吧。（主要观察你得后台服务是否还正常）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Android 6.0 改成这种电源管理模式以后，相当于强制我们使用GCM，国内目前GCM没有，不知道华为，小米等厂商怎么来使用6.0。最后还是希望明年Google部分服务回归吧，不然没法玩&amp;hellip;&amp;mdash;-一个写了两年IM的Android程序猿的独白&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅析ListView实现原理</title>
      <link>http://lorcanluo.github.io/post/%E6%B5%85%E6%9E%90ListView%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 28 Nov 2015 15:52:23 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/%E6%B5%85%E6%9E%90ListView%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>

&lt;p&gt;2009的Google Io大会中有一个专门培训ListView使用的&lt;a href=&#34;https://www.youtube.com/watch?v=wDBM6wVEO70&#34;&gt;课程&lt;/a&gt;说到，使用ListView 最快最优化（Fast Way）的方式如下这段代码：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fast Way&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```
public View getView(int position, View convertView, ViewGroup parent){
    ViewHolder holder;

    if (convertView == null) {
        convertView = mInflater.inflate(R.layout.list_item, parent, false);
        holder = new ViewHolder();
        holder.text = (TextView)convertView.findViewById(R.id.text);
        holder.icon = (ImageView)convertView.findViewById(R.id.icon);

        convertView.setTag(holder);
    } else {
        holder = (ViewHolder) convertView.getTag();
    }

    holder.text.setText(DATA[position]);
    holder.icon.setImageBitmap(Icons[position]);

    return convertView;
}

public static class ViewHolder{
    TextView text;
    ImageView icon;
}

```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当时好奇为什么要使用 covertView ， 所以结合源码看了下ListView的实现原理，几年过去了，已经忘的差不多了，最近整理一下，为什么我们在代码中要这么使用ListView？covertView又是什么东东？&lt;/p&gt;

&lt;h2 id=&#34;为什么要使用covertview:6e1e1fe882909f94253528cb85e0a255&#34;&gt;为什么要使用covertView？&lt;/h2&gt;

&lt;p&gt;大家都知道，如果从网络，或者本地获取到了数据，我们通过调用&lt;strong&gt;adapter.notifyDataSetChanaged()&lt;/strong&gt;来通知ListView数据已经发生改变，那么ListView就会把我们的数据更新到页面。我们将从这个方法看起，这个事件是怎么通知到ListView的？打开BaseAdapter的源码，我们看到notifyDataSetChanaged（）的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * Notifies the attached observers that the underlying data has been changed
     * and any View reflecting the data set should refresh itself.
     */
    public void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里调用了一个观察者模式的通知方法，那么你继续跟踪下去，将会在AbsListView中发现这个Observer的定义（注意这里有几个继承关系，所以你可能不是那么好找）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AdapterDataSetObserver extends DataSetObserver {

        private Parcelable mInstanceState = null;

        @Override
        public void onChanged() {
            mDataChanged = true;
            mOldItemCount = mItemCount;
            mItemCount = getAdapter().getCount();

            // Detect the case where a cursor that was previously invalidated has
            // been repopulated with new data.
            if (AdapterView.this.getAdapter().hasStableIds() &amp;amp;&amp;amp; mInstanceState != null
                    &amp;amp;&amp;amp; mOldItemCount == 0 &amp;amp;&amp;amp; mItemCount &amp;gt; 0) {
                AdapterView.this.onRestoreInstanceState(mInstanceState);
                mInstanceState = null;
            } else {
                rememberSyncState();
            }
            checkFocus();
            requestLayout();        //这里调用了requesetLayout 方法，那么ListView的绘制过程就开始了
        }

        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ViewGroup的绘制过程，大慨有三个阶段，onMeasure，onLayout, onDraw, onMeasuer阶段中，各个子View将会计计算自己在父View中占用的宽高， 父View通过测量阶段获取到的宽高信息，负责把子View放到合适的位置，具体的过程不在这里详谈，我们从ListView的Layout事件看起，ListView是继承至AbsListView，AbsListView onLayout()会调用一个方法叫layoutChildren（）这也是一个抽象方法，ListView实现了这个方法，下面我们将截取一段代码来分析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Override
 protected void layoutChildren() {
        
        ...省略的代码...
        
        try {
       
           ...省略的代码...
         
            boolean dataChanged = mDataChanged;
            if (dataChanged) {
                handleDataChanged();       //数据变化的处理，这里决定了mLayoutMode
            }

            // Handle the empty set by removing all views that are visible
            // and calling it a day
            //留这段代码在这里，是因为这是一个ListView很少见的crash，平时开发过程可能不会现，
            //上线以后就会出现偶发的crash，其实记住一点就好，如果Adapter中的数据发生了改变,就必须调用notifiyDateSetChangaed，
            //如果不调用，这个crash就会出现，我以前在环信的SDK中也发现过这问题
            if (mItemCount == 0) {
                resetList();
                invokeOnItemScrollListener();
                return;
            } else if (mItemCount != mAdapter.getCount()) {
                throw new IllegalStateException(&amp;quot;The content of the adapter has changed but &amp;quot;
                        + &amp;quot;ListView did not receive a notification. Make sure the content of &amp;quot;
                        + &amp;quot;your adapter is not modified from a background thread, but only from &amp;quot;
                        + &amp;quot;the UI thread. Make sure your adapter calls notifyDataSetChanged() &amp;quot;
                        + &amp;quot;when its content changes. [in ListView(&amp;quot; + getId() + &amp;quot;, &amp;quot; + getClass()
                        + &amp;quot;) with Adapter(&amp;quot; + mAdapter.getClass() + &amp;quot;)]&amp;quot;);
            }



            /*************重点来了******************/
            //这里如果数据发生了改变，将把所有现在的child放到scrapView中，
            //如果数据没有发生改变，将把所有现在的child放到activeViews中，
            //RecyCleBin是什么鬼？scrapView是什么鬼？activieViews又是什么鬼？

            // Pull all children into the RecycleBin.
            // These views will be reused if possible
            final int firstPosition = mFirstPosition;
            final RecycleBin recycleBin = mRecycler;
            if (dataChanged) {
                for (int i = 0; i &amp;lt; childCount; i++) {
                    recycleBin.addScrapView(getChildAt(i), firstPosition+i);
                }
            } else {
                recycleBin.fillActiveViews(childCount, firstPosition);
            }

            // Clear out old views
            detachAllViewsFromParent();
            recycleBin.removeSkippedScrap();

            //这里开始把子View加到ListView中，好多种模式，具体我没看，下面会选fillUp这个函数来分析。
            switch (mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition &amp;gt;= 0 &amp;amp;&amp;amp; mSelectedPosition &amp;lt; mItemCount) {
                        sel = fillSpecific(mSelectedPosition,
                                oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition &amp;lt; mItemCount) {
                        sel = fillSpecific(mFirstPosition,
                                oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
            }

            // Flush any cached views that did not get reused above
            recycleBin.scrapActiveViews();

            ...省略的代码...
            
        } finally {
            if (!blockLayoutRequests) {
                mBlockLayoutRequests = false;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面出现了RecycleBin， ScrapView，ActiveView，这是什么东西？我们打开RecycleBin的源码看一看。&lt;/p&gt;

&lt;h2 id=&#34;recyclebin:6e1e1fe882909f94253528cb85e0a255&#34;&gt;RecycleBin&lt;/h2&gt;

&lt;p&gt;源码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * The RecycleBin facilitates reuse of views across layouts. The RecycleBin has two levels of
     * storage: ActiveViews and ScrapViews. ActiveViews are those views which were onscreen at the
     * start of a layout. By construction, they are displaying current information. At the end of
     * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews are old views that
     * could potentially be used by the adapter to avoid allocating views unnecessarily.
     *
     * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener)
     * @see android.widget.AbsListView.RecyclerListener
     */
    class RecycleBin {
        private RecyclerListener mRecyclerListener;

        /**
         * The position of the first view stored in mActiveViews.
         */
        private int mFirstActivePosition;

        /**
         * Views that were on screen at the start of layout. This array is populated at the start of
         * layout, and at the end of layout all view in mActiveViews are moved to mScrapViews.
         * Views in mActiveViews represent a contiguous range of Views, with position of the first
         * view store in mFirstActivePosition.
         */
        private View[] mActiveViews = new View[0];

        /**
         * Unsorted views that can be used by the adapter as a convert view.
         */
        private ArrayList&amp;lt;View&amp;gt;[] mScrapViews;

        private int mViewTypeCount;

        private ArrayList&amp;lt;View&amp;gt; mCurrentScrap;

        private ArrayList&amp;lt;View&amp;gt; mSkippedScrap;

        private SparseArray&amp;lt;View&amp;gt; mTransientStateViews;
        private LongSparseArray&amp;lt;View&amp;gt; mTransientStateViewsById;
        
        
        ....省略的代码.....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面说的很清楚，RecycleBin的作用是帮助布局中的View的重用，它存储了两种类型的View：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mActiveViews  可以理解为现在显示在屏幕上的View&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mScrapViews&lt;/strong&gt;   我们终于找到了，这就是传回getView中covertView的来源，上面的作用也说的很清楚了，避免不必要的分配Views，优化性能。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ok，已经找到根本原因了，那么ListView又是在什么时候调用的getView方法了，上面说了我们将从fillUp方法看起：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; /**
     * Fills the list from pos up to the top of the list view.
     *
     * @param pos The first position to put in the list
     *
     * @param nextBottom The location where the bottom of the item associated
     *        with pos should be drawn
     *
     * @return The view that is currently selected
     */
    private View fillUp(int pos, int nextBottom) {
        View selectedView = null;

        int end = 0;
        if ((mGroupFlags &amp;amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            end = mListPadding.top;
        }

        while (nextBottom &amp;gt; end &amp;amp;&amp;amp; pos &amp;gt;= 0) {
            // is this the selected item?
            boolean selected = pos == mSelectedPosition;
            View child = makeAndAddView(pos, nextBottom, false, mListPadding.left, selected);
            nextBottom = child.getTop() - mDividerHeight;
            if (selected) {
                selectedView = child;
            }
            pos--;
        }

        mFirstPosition = pos + 1;
        setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);
        return selectedView;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这段代码中，又看到了makeAndAddView，该方法就是把View加到ListView中最终调用的方法，我们来看代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    /**
     * Obtain the view and add it to our list of children. The view can be made
     * fresh, converted from an unused view, or used as is if it was in the
     * recycle bin.
     *
     * @param position Logical position in the list
     * @param y Top or bottom edge of the view to add
     * @param flow If flow is true, align top edge to y. If false, align bottom
     *        edge to y.
     * @param childrenLeft Left edge where children should be positioned
     * @param selected Is this position selected?
     * @return View that was added
     */
    private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
            boolean selected) {
        View child;

        //如果数据没有变化，直接去ActiveView中拿，这是最快的。
        if (!mDataChanged) {
            // Try to use an existing view for this position
            child = mRecycler.getActiveView(position);
            if (child != null) {
                // Found it -- we&#39;re using an existing child
                // This just needs to be positioned
                setupChild(child, position, y, flow, childrenLeft, selected, true);

                return child;
            }
        }

        //如果数据变化了，新建一个View，或则如果可能的话去ScrapView中拿一个缓存。
        // Make a new view for this position, or convert an unused view if possible
        child = obtainView(position, mIsScrap);


        //这个方法负责，把View放到ListView中合适的位置，具体就不看代码了，有兴趣自己去看源码
        // This needs to be positioned and measured
        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

        return child;
    }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们只有接着看obtainView,该方法中就调用了getView方法，注意看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * Get a view and have it show the data associated with the specified
     * position. This is called when we have already discovered that the view is
     * not available for reuse in the recycle bin. The only choices left are
     * converting an old view or making a new one.
     *
     * @param position The position to display
     * @param isScrap Array of at least 1 boolean, the first entry will become true if
     *                the returned view was taken from the scrap heap, false if otherwise.
     *
     * @return A view displaying the data associated with the specified position
     */
    View obtainView(int position, boolean[] isScrap) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &amp;quot;obtainView&amp;quot;);

        isScrap[0] = false;

        //这个瞬时状态的View，看了下说明，大概就是item有动画等效果的，我们不关心这个
        // Check whether we have a transient state view. Attempt to re-bind the
        // data and discard the view if we fail.
        final View transientView = mRecycler.getTransientStateView(position);
        if (transientView != null) {
            final LayoutParams params = (LayoutParams) transientView.getLayoutParams();

            // If the view type hasn&#39;t changed, attempt to re-bind the data.
            if (params.viewType == mAdapter.getItemViewType(position)) {
                final View updatedView = mAdapter.getView(position, transientView, this);

                // If we failed to re-bind the data, scrap the obtained view.
                if (updatedView != transientView) {
                    setItemViewLayoutParams(updatedView, position);
                    mRecycler.addScrapView(updatedView, position);
                }
            }

            // Scrap view implies temporary detachment.
            isScrap[0] = true;
            return transientView;
        }

        //看这里，我们先去缓存中取一个scrapView
        final View scrapView = mRecycler.getScrapView(position);
        
        //看到没，这里调用了getView方法，去初始化我们的covertView，知道covertView怎么来的吧。
        final View child = mAdapter.getView(position, scrapView, this);
        if (scrapView != null) {
        
            //如果不相等，这种情况就是我们covertView为null的情况
            if (child != scrapView) {
                // Failed to re-bind the data, return scrap to the heap.
                mRecycler.addScrapView(scrapView, position);
            } else {
                isScrap[0] = true;
                
                //这个方法没有看到说明，大概就是绘制相关的
                child.dispatchFinishTemporaryDetach();
            }
        }

        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }

        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }

        setItemViewLayoutParams(child, position);

        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityDelegate == null) {
                mAccessibilityDelegate = new ListItemAccessibilityDelegate();
            }
            if (child.getAccessibilityDelegate() == null) {
                child.setAccessibilityDelegate(mAccessibilityDelegate);
            }
        }

        Trace.traceEnd(Trace.TRACE_TAG_VIEW);

        return child;
    }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok，大概就这样，ListView个人觉得他的实现是Android中一个比较经典的东西，如果看懂这个了的话，还可以看touch事件分发，ViewGroup绘制原理，有兴趣的同学可以深入的去看一下源码，绝对受益匪浅.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>谈谈源码中的SparseArray</title>
      <link>http://lorcanluo.github.io/post/%E8%B0%88%E8%B0%88%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84SparseArray/</link>
      <pubDate>Fri, 27 Nov 2015 18:43:17 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/%E8%B0%88%E8%B0%88%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84SparseArray/</guid>
      <description>

&lt;p&gt;在Andorid的源码和第三方库中，偶尔能看到该类，我们先来看一下官方文档的说明如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SparseArray map integers to Objects.  Unlike a normal array of  Objects,there can be gaps in the indices.  It is intended to be more memory efficient than using a HashMap to map Integers to Objects, both because it avoids auto-boxing keys and its data structure doesn&amp;rsquo;t rely on an extra entry object for each mapping.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的意思是SparseArray 用来替代HashMap Int到Object的这种关系。 它设计的目的是为了比HashMap更加节省内存，这是因为：
1. 它避免了键值的自动装箱
2. 他的数据结构不需要依赖额外的对象来完成映射。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that this container keeps its mappings in an array data structure,using a binary search to find keys.  The implementation is not intended to be appropriate for data structures that may contain large numbers of items.  It is generally slower than a traditional HashMap, since lookups require a binary search and adds and removes require inserting and deleting entries in the array.  For containers holding up to hundreds of items,the performance difference is not significant, less than 50%.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面说了，SparseArray通过二分查找键值，这种实现方式不太适合太多的item。通常情况他是比HashMap慢的，但是如果容器只有数百的item，这个性能损失不太重要，不超过50%。&lt;/p&gt;

&lt;p&gt;实际在Android环境中，我们的键值也很少有超过上千的，所以SparseArray我们能在项目中用到的地方还是不少，如果在Android Stuido出现一个黄色警告叫你替换的话，你就可以考虑替换了。因为对于Android 来说，内存往往比较重要一点。&lt;/p&gt;

&lt;h2 id=&#34;稀疏数组:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;稀疏数组&lt;/h2&gt;

&lt;p&gt;下面我们分析SparseArray的实现方式，从字面意思上翻译过来就是稀疏数组，首先我们打开源码看一下SparseArray的结构是怎么样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SparseArray&amp;lt;E&amp;gt; implements Cloneable {
    private static final Object DELETED = new Object();
    private boolean mGarbage = false;

    private int[] mKeys;
    private Object[] mValues;
    private int mSize;
    
    ........我是省略的代码哟..........   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看的出代码中有一个 int[] mKeys 数组， 和一个 Object[] mValues 数组，这两个就是存放键值和对象的地方，mSize是我们存入了多少键值对。下面我们将要用一个非常土的办法来看看这个结构是怎么样的，我们写一段测试代码如下，断点调试。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 SparseArray&amp;lt;Object&amp;gt; sparseArray = new SparseArray&amp;lt;&amp;gt;();
2 sparseArray.put(1, &amp;quot;11&amp;quot;);
3 sparseArray.put(8, &amp;quot;13&amp;quot;);
4 sparseArray.put(4, &amp;quot;12&amp;quot;);
5 sparseArray.put(0, &amp;quot;30&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们执行第二行代码以后：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mKey&lt;/strong&gt;中的结构:    {1,0,0,0,0,0,0,0,0,0,0,0}  后面的0是初始化mKey的长度
&lt;strong&gt;mValues&lt;/strong&gt;中的结构: {&amp;ldquo;11&amp;rdquo;}&lt;br /&gt;
&lt;strong&gt;mSize&lt;/strong&gt;: 1&lt;/p&gt;

&lt;p&gt;我们执行第三行代码以后：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mKey&lt;/strong&gt;中的结构:    {1,8,0,0,0,0,0,0,0,0,0,0}  后面的0是初始化mKey的长度
&lt;strong&gt;mValues&lt;/strong&gt;中的结构: {&amp;ldquo;11&amp;rdquo;,&amp;ldquo;13&amp;rdquo;}&lt;br /&gt;
&lt;strong&gt;mSize&lt;/strong&gt;: 2&lt;/p&gt;

&lt;p&gt;我们执行第三行代码以后：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mKey&lt;/strong&gt;中的结构:    {1,4,8,0,0,0,0,0,0,0,0,0}  后面的0是初始化mKey的长度
&lt;strong&gt;mValues&lt;/strong&gt;中的结构: {&amp;ldquo;11&amp;rdquo;,&amp;ldquo;12&amp;rdquo;,&amp;ldquo;13&amp;rdquo;}&lt;br /&gt;
&lt;strong&gt;mSize&lt;/strong&gt;: 3&lt;/p&gt;

&lt;p&gt;我们执行第三行代码以后：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mKey&lt;/strong&gt;中的结构:    {0,1,4,8,0,0,0,0,0,0,0,0,0}  后面的0是初始化mKey的长度
&lt;strong&gt;mValues&lt;/strong&gt;中的结构: {&amp;ldquo;30&amp;rdquo;,&amp;ldquo;11&amp;rdquo;,&amp;ldquo;12&amp;rdquo;,&amp;ldquo;13&amp;rdquo;}&lt;br /&gt;
&lt;strong&gt;mSize&lt;/strong&gt;: 4&lt;/p&gt;

&lt;p&gt;从以上的结构中我们可以判断出，如果我们想查找一个键值为4的key，那么首先第一步找到key对应在mKey数组中的index，那么对应的value就在对应mValues中的index位置。再仔细观察上面的mKey中的结构，你会发现mKey中的数字是递增的，那么这保证了我们就可以通过二分查找去找到某一个值在mkey中的位置。ok这个结构分析完毕之后，我们接下来看看，增，删，查，找功能。&lt;/p&gt;

&lt;h2 id=&#34;add:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;ADD&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * Adds a mapping from the specified key to the specified value,
     * replacing the previous mapping from the specified key if there
     * was one.
     */
    public void put(int key, E value) {
        //通过二分查找键值
        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

        //如果找到了 就直接替换
        if (i &amp;gt;= 0) {
            mValues[i] = value;
        } else {
            //如果没有找到，这个返回的值就是没有找到的mid+1 那么再取反 正好是当前mKey的存有值      
            //的下一个值，只能说好巧妙~~
            i = ~i;  

            if (i &amp;lt; mSize &amp;amp;&amp;amp; mValues[i] == DELETED) {
                mKeys[i] = key;
                mValues[i] = value;
                return;
            }

            if (mGarbage &amp;amp;&amp;amp; mSize &amp;gt;= mKeys.length) {
                gc();

                // Search again because indices may have changed.
                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
            }

            //GrowingArrayUtils 这个源码看不到，google下源码，就是他会动态增加数组的size,    
            //通过System.arraycopy 实现的，具体自己去google咯
            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
            mSize++;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;delete:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;Delete&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * Removes the mapping from the specified key, if there was any.
     */
    public void delete(int key) {
    
        //还是二分查找
        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

        //找到了删除
        if (i &amp;gt;= 0) {
            if (mValues[i] != DELETED) {
                mValues[i] = DELETED;
                mGarbage = true;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;Find&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * Gets the Object mapped from the specified key, or the specified Object
     * if no such mapping has been made.
     */
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E get(int key, E valueIfKeyNotFound) {
        //还是二分查找
        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

        if (i &amp;lt; 0 || mValues[i] == DELETED) {
            return valueIfKeyNotFound;
        } else {
            return (E) mValues[i];
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了以上的操作，都是通过二分查找来操作的，所以和HashMap相比， 性能还是有所损失的，最后看看GC的操作&lt;/p&gt;

&lt;h2 id=&#34;gc:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;GC&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; private void gc() {
        // Log.e(&amp;quot;SparseArray&amp;quot;, &amp;quot;gc start with &amp;quot; + mSize);

        int n = mSize;
        int o = 0;
        int[] keys = mKeys;
        Object[] values = mValues;

        //循环查找 找到了置空
        for (int i = 0; i &amp;lt; n; i++) {
            Object val = values[i];

            if (val != DELETED) {
                if (i != o) {
                    keys[o] = keys[i];
                    values[o] = val;
                    values[i] = null;
                }

                o++;
            }
        }

        mGarbage = false;
        mSize = o;

        // Log.e(&amp;quot;SparseArray&amp;quot;, &amp;quot;gc end with &amp;quot; + mSize);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结一下， 就是SpareArray 比HashMap更节约内存，但是性能不如HashMap，在Android系统这内存似金的年代，我们还是应该想尽各种办法去节约内存的。 SpareArray还有一个兄弟 叫LongSparsArray 实现原理也是一样的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android界面优化</title>
      <link>http://lorcanluo.github.io/post/Android%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 28 Oct 2015 15:52:23 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/Android%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/</guid>
      <description>

&lt;p&gt;工作几年，遇到需要页面优化的地方不少，在刚开始学写代码的时候大多数人只为了方便实现，而很少考虑效率问题，等到发现问题的时候回来修改，就会变得十分麻烦了。&lt;/p&gt;

&lt;p&gt;该文总结了Google Io大会的一个效率方面的培训，和我自己的一些经验。&lt;/p&gt;

&lt;h2 id=&#34;16毫秒原则:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;16毫秒原则&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lorcanluo/myHugoProject/master/myImage/optimizeUi/optimize_16ms.png&#34; alt=&#34;ui screenshot&#34; /&gt;
Android系统每隔&lt;strong&gt;16ms&lt;/strong&gt;发出&lt;strong&gt;VSYNC&lt;/strong&gt;信号，触发对UI进行渲染， 如果每次渲染都成功，这样就能够达到流畅的画面所需要的&lt;strong&gt;60fps&lt;/strong&gt;，为了能够实现&lt;strong&gt;60fps&lt;/strong&gt;，这意味着程序的大多数操作都必须在&lt;strong&gt;16ms&lt;/strong&gt;内完成。如图所示，如果你的操作都是在16ms内完成的，那么你的页面就是流畅的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_16ms2.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看上图，如果你的某个操作花费时间是&lt;strong&gt;24ms&lt;/strong&gt;，系统在得到&lt;strong&gt;VSYNC&lt;/strong&gt;信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在&lt;strong&gt;32ms&lt;/strong&gt;内看到的会是同一帧画面。&lt;/p&gt;

&lt;h2 id=&#34;什么原因会导致丢帧:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;什么原因会导致丢帧？&lt;/h2&gt;

&lt;p&gt;上面说了产生卡顿的原理，但是实际工作中，我们有哪些原因会引起这种问题呢：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;过度绘制：Layout 太复杂，UI重叠太多&lt;/li&gt;
&lt;li&gt;内存问题：GC频繁 内存泄露&lt;/li&gt;
&lt;li&gt;多线程处理不当，互锁产生&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;过度绘制:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;过度绘制&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Overdraw&lt;/strong&gt;(过度绘制) 描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_overdraw.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;调试overdraw的办法:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;调试OverDraw的办法&lt;/h4&gt;

&lt;p&gt;方法1：Android开发者选项中打开&lt;strong&gt;&lt;em&gt;调试GPU过度绘制&lt;/em&gt;&lt;/strong&gt;，页面上就会显示出不同的颜色。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;淡蓝色  表示只有一层 这是最好的情况&lt;/li&gt;
&lt;li&gt;浅绿色  表示有二层覆盖 这也还好&lt;/li&gt;
&lt;li&gt;淡红色  表示三层覆盖 我认为这种情况在实际工作中，还是很常见的&lt;/li&gt;
&lt;li&gt;深红色  表示4层以上的覆盖 这就比较严重了 需要自己研究下布局&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_overdraw2.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;方法二：DDMS 中有一个工具叫作：&lt;strong&gt;Hierarchy View&lt;/strong&gt; 这个工具就可以看出具体的布局了，你可以通过该工具分析具体的布局深度，但是该工具需要root手机，如果你的手机没有root，那么就用模拟器。下图是我的一个截图，大概就是这样子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_hierarchy.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;常用的一些android布局标签:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;常用的一些Android布局标签&lt;/h4&gt;

&lt;p&gt;我们还可以用一些Android提供的布局标签去优化我们的布局，有三个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Mergy&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;ViewStup&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Include&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;mergy:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;Mergy&lt;/h5&gt;

&lt;p&gt;Mergy标签的主要目的就是用来减少层级使用的，具体可以参考&lt;a href=&#34;http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-by.html&#34;&gt;http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-by.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;viewstup:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;ViewStup&lt;/h4&gt;

&lt;p&gt;ViewStup标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用标签，以减少内存使用量，加快渲染速度。具体可以参考&lt;a href=&#34;http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-with.html&#34;&gt;http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-with.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;include:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;Include&lt;/h4&gt;

&lt;p&gt;Include就是可以重用布局，具体对层级没啥优化效果，只是可以减少一部分重复代码。&lt;/p&gt;

&lt;p&gt;我写了Mergy和ViewStup的一个例子放在我的GitHub上，大家可以使用Hierarchy View 去观察布局的变化。 &lt;a href=&#34;https://github.com/lorcanluo/trainingOptimizingUI&#34;&gt;Samples-&amp;gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;内存问题-gc:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;内存问题-GC&lt;/h3&gt;

&lt;p&gt;虽然Android有自动管理内存的机制，但是对内存的不恰当使用仍然容易引起严重的性能问题。&lt;strong&gt;&lt;em&gt;在同一帧里面创建过多的对象是件需要特别引起注意的事情。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同 的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。模型如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_memory.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;为什么gc会引起卡顿了:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;为什么GC会引起卡顿了？&lt;/h4&gt;

&lt;p&gt;除了速度差异之外，执行GC操作的时候，&lt;strong&gt;&lt;em&gt;任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行&lt;/em&gt;&lt;/strong&gt;。
通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。&lt;strong&gt;&lt;em&gt;如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&#34;导致gc频繁的原因:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;导致GC频繁的原因：&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;Memory Churn内存抖动&lt;/strong&gt;，内存抖动是因为大量的对象被创建又在短时间内马上被释放。&lt;/p&gt;

&lt;p&gt;瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加 Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_memory2.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过Android提供的&lt;a href=&#34;https://developer.android.com/tools/performance/memory-monitor/index.html&#34;&gt;Memory Monitor&lt;/a&gt;工具就可以观察到这一现象，大概如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_memory3.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你看到图中的现象那么你就需要注意查看你得代码是否有问题了。&lt;/p&gt;

&lt;h4 id=&#34;内存泄露:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;内存泄露&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间&lt;/strong&gt;。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。&lt;/p&gt;

&lt;p&gt;Android也提供了工具去分析这些情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DDMS中的 Heap Tool&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Allocation tracker&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你还可以使用&lt;strong&gt;&lt;em&gt;MAT&lt;/em&gt;&lt;/strong&gt;去分析你得代码等等，具体内存分析的问题下一次再来讨论。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>