<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>骆二胖的博客</title>
    <link>http://lorcanluo.github.io/</link>
    <description>Recent content on 骆二胖的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 11 Jan 2016 11:40:16 +0800</lastBuildDate>
    <atom:link href="http://lorcanluo.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>一个可以到顶自动加载更多的ListView</title>
      <link>http://lorcanluo.github.io/post/%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%88%B0%E9%A1%B6%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%E7%9A%84ListView/</link>
      <pubDate>Mon, 11 Jan 2016 11:40:16 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%88%B0%E9%A1%B6%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%E7%9A%84ListView/</guid>
      <description>

&lt;p&gt;一个可以到顶自动加载更多的ListView，实现该控件的目的是用于im聊天页面场景，一些第三方实现的下拉加载更多也可以实现类似功能，但是由于他们实现的功能普遍比较复杂，效率相对较低，所以自己实现了该控件。&lt;/p&gt;

&lt;p&gt;Github 地址： &lt;a href=&#34;https://github.com/lorcanluo/TopAutoRefreshListView&#34;&gt;https://github.com/lorcanluo/TopAutoRefreshListView&lt;/a&gt;,如果你觉得有用， 麻烦star一下&lt;/p&gt;

&lt;h2 id=&#34;使用方法:0a067a8852473ff5d7517124caec92c5&#34;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;普通的使用方法和ListView一样，额外添加了两个方法&lt;/p&gt;

&lt;h3 id=&#34;设置listener:0a067a8852473ff5d7517124caec92c5&#34;&gt;设置Listener:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;       mListView.setOnTopRefreshListener(new TopAutoRefreshListView.OnTopRefreshListener() {
            @Override
            public void onTopRefresh() {
                
            }
        });

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在onTopRefresh（）方法中，添加数据加载的方法.&lt;/p&gt;

&lt;h3 id=&#34;停止刷新:0a067a8852473ff5d7517124caec92c5&#34;&gt;停止刷新：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; mListView.onTopRefreshFinished();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;问题:0a067a8852473ff5d7517124caec92c5&#34;&gt;问题&lt;/h2&gt;

&lt;p&gt;有什么问题，可以直接提交issus
或则联系我 email &lt;a href=&#34;mailto:763736665@qq.com&#34;&gt;763736665@qq.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android本地日志工具</title>
      <link>http://lorcanluo.github.io/post/Android%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 25 Dec 2015 21:41:29 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/Android%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7/</guid>
      <description>

&lt;p&gt;在日常开发过程中，一些后台服务，比如IM，后台定时任务，都需要一套本地日志系统来监控程序是否正常，Android本身提供的日志系统只能在终端显示，为了模拟一套和android Log系统相同的环境，我自己写了一套本地日志系统来解决以上问题。&lt;/p&gt;

&lt;p&gt;为了能让不同等级的日志以不同的颜色显示，我用html的方式来实现，这样我们通过浏览器打开就可以了。
演示效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/loghtml/htmldemo.png?raw=true&#34; alt=&#34;htmldemoimg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;github地址: &lt;a href=&#34;https://github.com/lorcanluo/LogLocal&#34;&gt;https://github.com/lorcanluo/LogLocal&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用方法:78090566b070caf4663a3c7d0c86897f&#34;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;在你的Application或则主Activity调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LogLocal.init(this.getPackageName());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法来初始化，传入参数为你需要存放文件的目录。&lt;/p&gt;

&lt;p&gt;目前支持三种级别的日志：&lt;/p&gt;

&lt;h3 id=&#34;普通消息:78090566b070caf4663a3c7d0c86897f&#34;&gt;普通消息&lt;/h3&gt;

&lt;p&gt;在文件中以黑色字体显示&lt;/p&gt;

&lt;p&gt;调用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * info log
     *
     * @param tag Used to identify the source of a log message.  It usually identifies
     *            the class or activity where the log call occurs.
     * @param msg The message you would like logged.
     */
    public static void i(String tag, String msg) {

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;调试信息:78090566b070caf4663a3c7d0c86897f&#34;&gt;调试信息&lt;/h3&gt;

&lt;p&gt;在文件中以绿色字体显示&lt;/p&gt;

&lt;p&gt;调用方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
     * debug log
     *
     * @param tag Used to identify the source of a log message.  It usually identifies
     *            the class or activity where the log call occurs.
     * @param msg The message you would like logged.
     */
    public static void d(String tag, String msg) {
     
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;错误信息:78090566b070caf4663a3c7d0c86897f&#34;&gt;错误信息&lt;/h3&gt;

&lt;p&gt;在文件中以红色字体显示&lt;/p&gt;

&lt;p&gt;调用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * error log
     *
     * @param tag Used to identify the source of a log message.  It usually identifies
     *            the class or activity where the log call occurs.
     * @param msg The message you would like logged.
     */
    public static void e(String tag, String msg) {

    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;关闭日志:78090566b070caf4663a3c7d0c86897f&#34;&gt;关闭日志&lt;/h3&gt;

&lt;p&gt;如果你不想在正式环境输出日志，可以调用以下方法来屏蔽日志输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * open or close the function
 *
 * @param isDebuggable if set to false, not print the message.
 */
 public static void setIsDebuggable(boolean isDebuggable)()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##问题
有什么问题，可以直接提交issus
或则联系我 email &lt;a href=&#34;mailto:763736665@qq.com&#34;&gt;763736665@qq.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Touch事件的分发机制</title>
      <link>http://lorcanluo.github.io/post/Touch%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Thu, 03 Dec 2015 16:27:25 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/Touch%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</guid>
      <description>

&lt;p&gt;网上很多用源码来分析touch事件机制的文章，但是由于View和ViewGroup事件分发和android系统事件分开有关系，所以看起来有点云里雾里的，下面自己写了一个例子来说嘛touch分发的原理，和我们工作中遇到此类问题应该怎么处理这类事件，首先必须知道的一点是ViewGroup是继承至ViewG的，这个你们可以去源码中看看，接下来我们来说明ViewGroup和View下的三个相关Touch分发的函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dispatchTouchEvent（）&lt;/strong&gt;: 该方法用于touch事件的分发， view和viewgroup都实现了该方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onTouchEvent（）&lt;/strong&gt;: 该方法就是用于具体的touch事件处理，这个方法实现在View中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onInterceptTouchEvent（）&lt;/strong&gt;: 该方法用于拦截touch事件，这个方法只有ViewGroup有。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来我们先看看源码中的官方说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; /**
     * Pass the touch screen motion event down to the target view, or this
     * view if it is the target.
     *
     * @param event The motion event to be dispatched.
     * @return True if the event was handled by the view, false otherwise.
     */
    public boolean dispatchTouchEvent(MotionEvent event) {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面写的很清楚，分发事件到对应的view，这是View源码中的类，实际ViewGroup中的更复杂，他多了一个功能就是还要往子View分发事件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
     * Implement this method to handle touch screen motion events.
     * &amp;lt;p&amp;gt;
     * If this method is used to detect click actions, it is recommended that
     * the actions be performed by implementing and calling
     * {@link #performClick()}. This will ensure consistent system behavior,
     * including:
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;obeying click sound preferences
     * &amp;lt;li&amp;gt;dispatching OnClickListener calls
     * &amp;lt;li&amp;gt;handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
     * accessibility features are enabled
     * &amp;lt;/ul&amp;gt;
     *
     * @param event The motion event.
     * @return True if the event was handled, false otherwise.
     */
    public boolean onTouchEvent(MotionEvent event) {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个方法就是我们经常用到的，具体对touch事件的处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /**
     * Implement this method to intercept all touch screen motion events.  This
     * allows you to watch events as they are dispatched to your children, and
     * take ownership of the current gesture at any point.
     *
     * &amp;lt;p&amp;gt;Using this function takes some care, as it has a fairly complicated
     * interaction with {@link View#onTouchEvent(MotionEvent)
     * View.onTouchEvent(MotionEvent)}, and using it requires implementing
     * that method as well as this one in the correct way.  Events will be
     * received in the following order:
     *
     * &amp;lt;ol&amp;gt;
     * &amp;lt;li&amp;gt; You will receive the down event here.
     * &amp;lt;li&amp;gt; The down event will be handled either by a child of this view
     * group, or given to your own onTouchEvent() method to handle; this means
     * you should implement onTouchEvent() to return true, so you will
     * continue to see the rest of the gesture (instead of looking for
     * a parent view to handle it).  Also, by returning true from
     * onTouchEvent(), you will not receive any following
     * events in onInterceptTouchEvent() and all touch processing must
     * happen in onTouchEvent() like normal.
     * &amp;lt;li&amp;gt; For as long as you return false from this function, each following
     * event (up to and including the final up) will be delivered first here
     * and then to the target&#39;s onTouchEvent().
     * &amp;lt;li&amp;gt; If you return true from here, you will not receive any
     * following events: the target view will receive the same event but
     * with the action {@link MotionEvent#ACTION_CANCEL}, and all further
     * events will be delivered to your onTouchEvent() method and no longer
     * appear here.
     * &amp;lt;/ol&amp;gt;
     *
     * @param ev The motion event being dispatched down the hierarchy.
     * @return Return true to steal motion events from the children and have
     * them dispatched to this ViewGroup through onTouchEvent().
     * The current target will receive an ACTION_CANCEL event, and no further
     * messages will be delivered here.
     */
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个函数可以看看应该，这个函数是用来拦截touch事件的，默认返回的是false，如果返回true，当前的View的dispatchTouchEvent（）和onTouchEvent（）还会运行，但是子View的相关函数将不再运行。&lt;/p&gt;

&lt;h2 id=&#34;测试工程:457fc3a4f9a21adbc9d68d0ec7987901&#34;&gt;测试工程&lt;/h2&gt;

&lt;p&gt;下面我用一个例子来说明这个问题，我建立了一个工程，自定义了三个MyLinearLayout，MyLinearLayout1，MyLinearLayout2类继承至LinearLayout,同样的代码如下，但是有三个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyLinearLayout extends LinearLayout {
    public MyLinearLayout(Context context) {
        super(context);
    }

    public MyLinearLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        Log.d(&amp;quot;MyLinearLayout&amp;quot;, &amp;quot;onInterceptTouchEvent&amp;quot;);

        return super.onInterceptTouchEvent(ev);
    }


    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        Log.d(&amp;quot;MyLinearLayout&amp;quot;, &amp;quot;dispatchTouchEvent&amp;quot;);


        return super.dispatchTouchEvent(ev);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        Log.d(&amp;quot;MyLinearLayout&amp;quot;, &amp;quot;onTouchEvent&amp;quot;);

        return super.onTouchEvent(event);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还写了一个MyTextView类，继承于TextView，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyTestView extends TextView {
    public MyTestView(Context context) {
        super(context);
    }

    public MyTestView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyTestView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        Log.d(&amp;quot;MyTestView&amp;quot;, &amp;quot;dispatchTouchEvent&amp;quot;);

        return super.dispatchTouchEvent(event);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        Log.d(&amp;quot;MyTestView&amp;quot;, &amp;quot;onTouchEvent&amp;quot;);

        return super.onTouchEvent(event);
    }


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的布局代码代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot;
    android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;
    android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;
    android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;
    tools:context=&amp;quot;github.lorcanluo.testdispatch.MainActivity&amp;quot;&amp;gt;

    &amp;lt;github.lorcanluo.testdispatch.MyLinearLayout
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;500dp&amp;quot;
        android:background=&amp;quot;#ff0000&amp;quot;
        android:padding=&amp;quot;20dp&amp;quot;&amp;gt;

        &amp;lt;github.lorcanluo.testdispatch.MyLinearLayout1
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;match_parent&amp;quot;
            android:background=&amp;quot;#00ff00&amp;quot;
            android:padding=&amp;quot;30dp&amp;quot;&amp;gt;

            &amp;lt;github.lorcanluo.testdispatch.MyLinearLayout2
                android:layout_width=&amp;quot;match_parent&amp;quot;
                android:layout_height=&amp;quot;match_parent&amp;quot;
                android:gravity=&amp;quot;center&amp;quot;
                android:background=&amp;quot;#0000ff&amp;quot;&amp;gt;

                &amp;lt;github.lorcanluo.testdispatch.MyTestView
                    android:layout_width=&amp;quot;100dp&amp;quot;
                    android:layout_height=&amp;quot;100dp&amp;quot;
                    android:gravity=&amp;quot;center&amp;quot;
                    android:background=&amp;quot;#ffffff&amp;quot;
                    android:text=&amp;quot;我就是小打杂&amp;quot; /&amp;gt;

            &amp;lt;/github.lorcanluo.testdispatch.MyLinearLayout2&amp;gt;

        &amp;lt;/github.lorcanluo.testdispatch.MyLinearLayout1&amp;gt;


    &amp;lt;/github.lorcanluo.testdispatch.MyLinearLayout&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;布局出来的效果如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lorcanluo/myHugoProject/master/myImage/touch/dispatch_phone.png&#34; alt=&#34;phone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来我们来使用不同的操作，来输出日志，首先看一下什么都没改的日志输出如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lorcanluo/myHugoProject/master/myImage/touch/normal.png&#34; alt=&#34;phone&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;mytextview的ontouchevent中返回true:457fc3a4f9a21adbc9d68d0ec7987901&#34;&gt;MyTextView的onTouchEvent中返回true&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    @Override
    public boolean onTouchEvent(MotionEvent event) {
        Log.d(&amp;quot;MyTestView&amp;quot;, &amp;quot;onTouchEvent&amp;quot;);

        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么输出如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lorcanluo/myHugoProject/master/myImage/touch/mytextview_ontouch_return_true.png&#34; alt=&#34;phone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到日志中，只有MyTextView的onTouchEvent()事件了，这表示事件已经被我们消耗了，父类不用再处理onTouchEvent（）事件了,如果这里你手动返回false的话，那么父类的onTouchEvent()事件还是会响应的。&lt;/p&gt;

&lt;h3 id=&#34;mytextview的dispatchtouchevent-中返回true:457fc3a4f9a21adbc9d68d0ec7987901&#34;&gt;MyTextView的dispatchTouchEvent（）中返回true&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        Log.d(&amp;quot;MyTestView&amp;quot;, &amp;quot;dispatchTouchEvent&amp;quot;);

        return true;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dispatchTouchEvent（）函数中返回true以后，表示事件已经被&amp;rdquo;消耗&amp;rdquo;,那么所有相关的onTouchEvent（）将不再输出，所以我们得出的输出结果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lorcanluo/myHugoProject/master/myImage/touch/view_dispatch_return_true.png&#34; alt=&#34;phone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果父类的dispatchTouchEvent（）返回true之后，&lt;strong&gt;本类和父view的onTouchEvent（）事件不再调用，子类的所有touch事件不再调用&lt;/strong&gt;，这和接下来的onInterceptTouchEvent（）还是有区别，需要细心分别。&lt;/p&gt;

&lt;h3 id=&#34;mylinearlayout1的onintercepttouchevent-中返回true:457fc3a4f9a21adbc9d68d0ec7987901&#34;&gt;MyLinearLayout1的onInterceptTouchEvent（）中返回true&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        Log.d(&amp;quot;MyLinearLayout1&amp;quot;, &amp;quot;onInterceptTouchEvent&amp;quot;);


        return true;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事件被拦截以后，子view的相关touch事件将不再调用，&lt;strong&gt;但是本类和父类事件还是要调用的&lt;/strong&gt;，这里和上面dispatchTouchEvent（）还是有差别，需要仔细区分，我们的输出如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lorcanluo/myHugoProject/master/myImage/touch/layout1_intercept_return_true.png&#34; alt=&#34;phone&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;日常处理touch冲突的常用办法:457fc3a4f9a21adbc9d68d0ec7987901&#34;&gt;日常处理Touch冲突的常用办法&lt;/h2&gt;

&lt;p&gt;在日常工作中，我们还是有可能遇到touch事件冲突的问题的，那么有了上面的知识，我们可以通过以上函数处理的组合来处理事件冲突。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果我们想阻断子View对touch事件的处理，我们可以通过onInterceptTouchEvent（）方法来进行判断是否阻断&lt;/li&gt;
&lt;li&gt;如果我们想让父类不再处理onTouchEvent（）事件，我们可以通过在onTouchEvent（）中返回true来进行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是还可能有更为复杂的情况，这就需要大家去动态的算法处理了。。。。&lt;/p&gt;

&lt;p&gt;本文的例子放在了：&lt;a href=&#34;https://github.com/lorcanluo/testDispatchTouchEvent&#34;&gt;https://github.com/lorcanluo/testDispatchTouchEvent&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UniversalImageLoader中的LruMemoryCache</title>
      <link>http://lorcanluo.github.io/post/UniversalImageLoader%E4%B8%AD%E7%9A%84LruMemoryCache/</link>
      <pubDate>Tue, 01 Dec 2015 14:54:30 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/UniversalImageLoader%E4%B8%AD%E7%9A%84LruMemoryCache/</guid>
      <description>

&lt;p&gt;在UniversalImageLoader中缓存在内存中的数据就使用了LruCache类，叫LruMemoryCache，存在内存中的图片就是放在该类中了，想想早年我们用软引用的方式保存，也是弱爆了&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;lru:5426630547b6f65ea3d8109cd3c5804a&#34;&gt;Lru&lt;/h2&gt;

&lt;p&gt;Lru（Least recently used，最近最少使用）是一个缓存淘汰算法的简写，如果数据长时间没有被访问，那么缓存数据容量满的的时候，将会淘汰最少使用的数据。 我们直接看LruMemoryCache的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * A cache that holds strong references to a limited number of Bitmaps. Each time a Bitmap is accessed, it is moved to
 * the head of a queue. When a Bitmap is added to a full cache, the Bitmap at the end of that queue is evicted and may
 * become eligible for garbage collection.&amp;lt;br /&amp;gt;
 * &amp;lt;br /&amp;gt;
 * &amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; This cache uses only strong references for stored Bitmaps.
 *
 * @author Sergey Tarasevich (nostra13[at]gmail[dot]com)
 * @since 1.8.1
 */
public class LruMemoryCache implements MemoryCache {

   //LinkedHashMap accessOrder设为true以后，最近访问的数据将会被放到前面，
	private final LinkedHashMap&amp;lt;String, Bitmap&amp;gt; map;

	private final int maxSize;
	/** Size of this cache in bytes */
	private int size;

	/** @param maxSize Maximum sum of the sizes of the Bitmaps in this cache */
	public LruMemoryCache(int maxSize) {
		if (maxSize &amp;lt;= 0) {
			throw new IllegalArgumentException(&amp;quot;maxSize &amp;lt;= 0&amp;quot;);
		}
		
		//maxSize universal分配的策略是分配给应用的内存的1/8
		this.maxSize = maxSize;
		
		//设为true了
		this.map = new LinkedHashMap&amp;lt;String, Bitmap&amp;gt;(0, 0.75f, true);
	}

	/**
	 * Returns the Bitmap for {@code key} if it exists in the cache. If a Bitmap was returned, it is moved to the head
	 * of the queue. This returns null if a Bitmap is not cached.
	 */
	@Override
	public final Bitmap get(String key) {
		if (key == null) {
			throw new NullPointerException(&amp;quot;key == null&amp;quot;);
		}

     //LinkHashMap是非线程安全的，所以要自己同步，这里get以后，LinkedHashMap就会把数据放在最前面
		synchronized (this) {
			return map.get(key);
		}
	}

	/** Caches {@code Bitmap} for {@code key}. The Bitmap is moved to the head of the queue. */
	@Override
	public final boolean put(String key, Bitmap value) {
		if (key == null || value == null) {
			throw new NullPointerException(&amp;quot;key == null || value == null&amp;quot;);
		}

		synchronized (this) {
		   //加上当前的size
			size += sizeOf(key, value);
			Bitmap previous = map.put(key, value);
			
			//如果key存在，要减去以前的size
			if (previous != null) {
				size -= sizeOf(key, previous);
			}
		}

      //清理缓存，如果超出最大值，则需要删除老的数据
		trimToSize(maxSize);
		return true;
	}

	/**
	 * Remove the eldest entries until the total of remaining entries is at or below the requested size.
	 *
	 * @param maxSize the maximum size of the cache before returning. May be -1 to evict even 0-sized elements.
	 */
	private void trimToSize(int maxSize) {
		while (true) {
			String key;
			Bitmap value;
			synchronized (this) {
				if (size &amp;lt; 0 || (map.isEmpty() &amp;amp;&amp;amp; size != 0)) {
					throw new IllegalStateException(getClass().getName() + &amp;quot;.sizeOf() is reporting inconsistent results!&amp;quot;);
				}

				if (size &amp;lt;= maxSize || map.isEmpty()) {
					break;
				}
				
           //删除老的数据直至 size&amp;lt;maxSize
				Map.Entry&amp;lt;String, Bitmap&amp;gt; toEvict = map.entrySet().iterator().next();
				if (toEvict == null) {
					break;
				}
				key = toEvict.getKey();
				value = toEvict.getValue();
				map.remove(key);
				size -= sizeOf(key, value);
			}
		}
	}

	/** Removes the entry for {@code key} if it exists. */
	@Override
	public final Bitmap remove(String key) {
		if (key == null) {
			throw new NullPointerException(&amp;quot;key == null&amp;quot;);
		}

		synchronized (this) {
			Bitmap previous = map.remove(key);
			if (previous != null) {
				size -= sizeOf(key, previous);
			}
			return previous;
		}
	}

	@Override
	public Collection&amp;lt;String&amp;gt; keys() {
		synchronized (this) {
			return new HashSet&amp;lt;String&amp;gt;(map.keySet());
		}
	}

	@Override
	public void clear() {
		trimToSize(-1); // -1 will evict 0-sized elements
	}

	/**
	 * Returns the size {@code Bitmap} in bytes.
	 * &amp;lt;p/&amp;gt;
	 * An entry&#39;s size must not change while it is in the cache.
	 */
	private int sizeOf(String key, Bitmap value) {
		return value.getRowBytes() * value.getHeight();
	}

	@Override
	public synchronized final String toString() {
		return String.format(&amp;quot;LruCache[maxSize=%d]&amp;quot;, maxSize);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lrucache:5426630547b6f65ea3d8109cd3c5804a&#34;&gt;LruCache&lt;/h2&gt;

&lt;p&gt;Android 4.0以后官方也引入了一个缓存类叫LruCache，可以直接在源码中找到该类，具体实现和上类似，只是这是一个泛型的实现，具体如果以后大家用的到，可以去源码中查询。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>android6.0电源管理方式</title>
      <link>http://lorcanluo.github.io/post/android6.0%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 30 Nov 2015 17:54:12 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/android6.0%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</guid>
      <description>

&lt;p&gt;从Android 6.0开始，Android引入了两种电源优化特性来延长电源使用时间。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Doze：休眠状态&lt;/li&gt;
&lt;li&gt;App Standby：App 挂起&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;doze:ae9920511987a07389ba2d8a27b5e486&#34;&gt;Doze&lt;/h2&gt;

&lt;p&gt;如果用户手机未充电并且屏幕关闭一段时间以后，设备将进入休眠模式。在休眠状态下，系统将通过以下两种方式来节省电量：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;限制app访问网络&lt;/li&gt;
&lt;li&gt;限制大量占用Cpu的Service&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;并且阻止APP访问网络，推迟APP的任务，同步和标准闹钟。&lt;/p&gt;

&lt;p&gt;在该模式下，系统周期性的退出休眠状态一小段时间使得app能完成他们推迟的工作。见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lorcanluo/myHugoProject/master/myImage/optimizeUi/doze.png&#34; alt=&#34;doze&#34; /&gt;&lt;/p&gt;

&lt;p&gt;见上图，系统周期的退出Doze模式，来呼起延迟的操作.
当用户移动设备，打开屏幕或则连接电源唤醒设备以后，系统将退出休眠模式并且所有app将会进入正常活动状态。&lt;/p&gt;

&lt;h3 id=&#34;doze-restrictions:ae9920511987a07389ba2d8a27b5e486&#34;&gt;Doze restrictions&lt;/h3&gt;

&lt;p&gt;休眠模式下，将会限制以下你的app操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网络访问将会挂起&lt;/li&gt;
&lt;li&gt;系统将会忽略 wake lock&lt;/li&gt;
&lt;li&gt;标准的AlarmManager(setExact()和setWindow（））)将会推迟到下一个maintenance window.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你在休眠状态下需要alarms 可以使用setAndAllowWhileIdle()或则setExactAndAllowWhileIdel（）方法。&lt;/p&gt;

&lt;p&gt;用setAlarmClock()的闹钟不受影响-系统会短暂的退出休眠模式来唤起这个闹钟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;系统不再扫描Wi_Fi&lt;/li&gt;
&lt;li&gt;系统不允许sync adapter运行&lt;/li&gt;
&lt;li&gt;系统不允许JobScheduler运行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;适配你的app到doze状态:ae9920511987a07389ba2d8a27b5e486&#34;&gt;适配你的app到Doze状态&lt;/h3&gt;

&lt;p&gt;取决于你用的特性和服务，Doze对App的影响是不同的，如果你用了上述的一些功能，那么你需要调整你得App。&lt;/p&gt;

&lt;p&gt;对使用AlarmManager的App，6.0引入了两个新的方法：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;setAndAllowWhileIdle()&lt;/p&gt;

&lt;p&gt;setExactAndAllowWhileIdle().&lt;/p&gt;

&lt;p&gt;但是就算加了这两个方法,每15分钟闹钟服务只能允许呼起一次&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么对于我们这种实时消息（IM）开发的将是一个噩耗，那么Google推荐的方式是使用&lt;strong&gt;GCM&lt;/strong&gt; ，我们木有啊，木有啊，所以我觉得6.0在国内暂时还需要一段时间。&lt;/p&gt;

&lt;h2 id=&#34;app-standby:ae9920511987a07389ba2d8a27b5e486&#34;&gt;App Standby&lt;/h2&gt;

&lt;p&gt;当用户没有和一个App交互的时候，系统将会决定这个app是否是非活跃状态，这就是App Standby.当用户一段时间内没有点击app并且没有以下的这些条件的时候，系统将会决定是否进入挂起状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户显示的启动了app&lt;/li&gt;
&lt;li&gt;app当前在前台有任务在处理&lt;/li&gt;
&lt;li&gt;app产生了一条通知&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当用户插上电源以后，系统将会释放app的挂起状态，这时候允许app自由的访问网络，执行等待的jobs和syncs。如果设备长时间处于非活跃状态，系统只允许这些app一天访问一次网络。&lt;/p&gt;

&lt;h3 id=&#34;所以我们只能使用gcm有木有-有木有-国内木有有木有-咋个办-我还不知道:ae9920511987a07389ba2d8a27b5e486&#34;&gt;所以我们只能使用GCM有木有？有木有？国内木有有木有？咋个办？我还不知道&amp;hellip;..&lt;/h3&gt;

&lt;p&gt;这个问题只能等待国内厂商解决了!&lt;/p&gt;

&lt;h3 id=&#34;白名单:ae9920511987a07389ba2d8a27b5e486&#34;&gt;白名单&lt;/h3&gt;

&lt;p&gt;用户可以在电源管理里面把app加入白名单。&lt;/p&gt;

&lt;h2 id=&#34;模拟doze状态测试app:ae9920511987a07389ba2d8a27b5e486&#34;&gt;模拟Doze状态测试app&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;找一个6.0以上的手机或则虚拟机&lt;/li&gt;
&lt;li&gt;连接设备到你的开发机并安装你的应用&lt;/li&gt;
&lt;li&gt;打开你得应用&lt;/li&gt;
&lt;li&gt;关掉屏幕（app还处于活跃状态）&lt;/li&gt;
&lt;li&gt;运行以下命令强制系统进入Doze状态&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;   $ adb shell dumpsys battery unplug
   $ adb shell dumpsys deviceidle step
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能需要运行第二行命令多次，重复直至设备进入休眠状态
6. 观察APP状态，然后填坑吧&lt;/p&gt;

&lt;h2 id=&#34;模拟app-standby测试app:ae9920511987a07389ba2d8a27b5e486&#34;&gt;模拟app standby测试app&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;找一个6.0以上的手机或则虚拟机&lt;/li&gt;
&lt;li&gt;连接设备到你的开发机并安装你的应用&lt;/li&gt;
&lt;li&gt;打开你得应用&lt;/li&gt;
&lt;li&gt;运行以下命令强制系统进入app stanby状态&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;   $ adb shell dumpsys battery unplug
   $ adb shell am set-inactive &amp;lt;packageName&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;运行以下命令模拟唤醒你得app&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;   $ adb shell am set-inactive &amp;lt;packageName&amp;gt; false
   $ adb shell am get-inactive &amp;lt;packageName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;观察你得app，填坑吧。（主要观察你得后台服务是否还正常）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Android 6.0 改成这种电源管理模式以后，相当于强制我们使用GCM，国内目前GCM没有，不知道华为，小米等厂商怎么来使用6.0。最后还是希望明年Google部分服务回归吧，不然没法玩&amp;hellip;&amp;mdash;-一个写了两年IM的Android程序猿的独白&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅析ListView实现原理</title>
      <link>http://lorcanluo.github.io/post/%E6%B5%85%E6%9E%90ListView%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 28 Nov 2015 15:52:23 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/%E6%B5%85%E6%9E%90ListView%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>

&lt;p&gt;2009的Google Io大会中有一个专门培训ListView使用的&lt;a href=&#34;https://www.youtube.com/watch?v=wDBM6wVEO70&#34;&gt;课程&lt;/a&gt;说到，使用ListView 最快最优化（Fast Way）的方式如下这段代码：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fast Way&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```
public View getView(int position, View convertView, ViewGroup parent){
    ViewHolder holder;

    if (convertView == null) {
        convertView = mInflater.inflate(R.layout.list_item, parent, false);
        holder = new ViewHolder();
        holder.text = (TextView)convertView.findViewById(R.id.text);
        holder.icon = (ImageView)convertView.findViewById(R.id.icon);

        convertView.setTag(holder);
    } else {
        holder = (ViewHolder) convertView.getTag();
    }

    holder.text.setText(DATA[position]);
    holder.icon.setImageBitmap(Icons[position]);

    return convertView;
}

public static class ViewHolder{
    TextView text;
    ImageView icon;
}

```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当时好奇为什么要使用 covertView ， 所以结合源码看了下ListView的实现原理，几年过去了，已经忘的差不多了，最近整理一下，为什么我们在代码中要这么使用ListView？covertView又是什么东东？&lt;/p&gt;

&lt;h2 id=&#34;为什么要使用covertview:6e1e1fe882909f94253528cb85e0a255&#34;&gt;为什么要使用covertView？&lt;/h2&gt;

&lt;p&gt;大家都知道，如果从网络，或者本地获取到了数据，我们通过调用&lt;strong&gt;adapter.notifyDataSetChanaged()&lt;/strong&gt;来通知ListView数据已经发生改变，那么ListView就会把我们的数据更新到页面。我们将从这个方法看起，这个事件是怎么通知到ListView的？打开BaseAdapter的源码，我们看到notifyDataSetChanaged（）的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * Notifies the attached observers that the underlying data has been changed
     * and any View reflecting the data set should refresh itself.
     */
    public void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里调用了一个观察者模式的通知方法，那么你继续跟踪下去，将会在AbsListView中发现这个Observer的定义（注意这里有几个继承关系，所以你可能不是那么好找）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AdapterDataSetObserver extends DataSetObserver {

        private Parcelable mInstanceState = null;

        @Override
        public void onChanged() {
            mDataChanged = true;
            mOldItemCount = mItemCount;
            mItemCount = getAdapter().getCount();

            // Detect the case where a cursor that was previously invalidated has
            // been repopulated with new data.
            if (AdapterView.this.getAdapter().hasStableIds() &amp;amp;&amp;amp; mInstanceState != null
                    &amp;amp;&amp;amp; mOldItemCount == 0 &amp;amp;&amp;amp; mItemCount &amp;gt; 0) {
                AdapterView.this.onRestoreInstanceState(mInstanceState);
                mInstanceState = null;
            } else {
                rememberSyncState();
            }
            checkFocus();
            requestLayout();        //这里调用了requesetLayout 方法，那么ListView的绘制过程就开始了
        }

        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ViewGroup的绘制过程，大慨有三个阶段，onMeasure，onLayout, onDraw, onMeasuer阶段中，各个子View将会计计算自己在父View中占用的宽高， 父View通过测量阶段获取到的宽高信息，负责把子View放到合适的位置，具体的过程不在这里详谈，我们从ListView的Layout事件看起，ListView是继承至AbsListView，AbsListView onLayout()会调用一个方法叫layoutChildren（）这也是一个抽象方法，ListView实现了这个方法，下面我们将截取一段代码来分析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Override
 protected void layoutChildren() {
        
        ...省略的代码...
        
        try {
       
           ...省略的代码...
         
            boolean dataChanged = mDataChanged;
            if (dataChanged) {
                handleDataChanged();       //数据变化的处理，这里决定了mLayoutMode
            }

            // Handle the empty set by removing all views that are visible
            // and calling it a day
            //留这段代码在这里，是因为这是一个ListView很少见的crash，平时开发过程可能不会现，
            //上线以后就会出现偶发的crash，其实记住一点就好，如果Adapter中的数据发生了改变,就必须调用notifiyDateSetChangaed，
            //如果不调用，这个crash就会出现，我以前在环信的SDK中也发现过这问题
            if (mItemCount == 0) {
                resetList();
                invokeOnItemScrollListener();
                return;
            } else if (mItemCount != mAdapter.getCount()) {
                throw new IllegalStateException(&amp;quot;The content of the adapter has changed but &amp;quot;
                        + &amp;quot;ListView did not receive a notification. Make sure the content of &amp;quot;
                        + &amp;quot;your adapter is not modified from a background thread, but only from &amp;quot;
                        + &amp;quot;the UI thread. Make sure your adapter calls notifyDataSetChanged() &amp;quot;
                        + &amp;quot;when its content changes. [in ListView(&amp;quot; + getId() + &amp;quot;, &amp;quot; + getClass()
                        + &amp;quot;) with Adapter(&amp;quot; + mAdapter.getClass() + &amp;quot;)]&amp;quot;);
            }



            /*************重点来了******************/
            //这里如果数据发生了改变，将把所有现在的child放到scrapView中，
            //如果数据没有发生改变，将把所有现在的child放到activeViews中，
            //RecyCleBin是什么鬼？scrapView是什么鬼？activieViews又是什么鬼？

            // Pull all children into the RecycleBin.
            // These views will be reused if possible
            final int firstPosition = mFirstPosition;
            final RecycleBin recycleBin = mRecycler;
            if (dataChanged) {
                for (int i = 0; i &amp;lt; childCount; i++) {
                    recycleBin.addScrapView(getChildAt(i), firstPosition+i);
                }
            } else {
                recycleBin.fillActiveViews(childCount, firstPosition);
            }

            // Clear out old views
            detachAllViewsFromParent();
            recycleBin.removeSkippedScrap();

            //这里开始把子View加到ListView中，好多种模式，具体我没看，下面会选fillUp这个函数来分析。
            switch (mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition &amp;gt;= 0 &amp;amp;&amp;amp; mSelectedPosition &amp;lt; mItemCount) {
                        sel = fillSpecific(mSelectedPosition,
                                oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition &amp;lt; mItemCount) {
                        sel = fillSpecific(mFirstPosition,
                                oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
            }

            // Flush any cached views that did not get reused above
            recycleBin.scrapActiveViews();

            ...省略的代码...
            
        } finally {
            if (!blockLayoutRequests) {
                mBlockLayoutRequests = false;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面出现了RecycleBin， ScrapView，ActiveView，这是什么东西？我们打开RecycleBin的源码看一看。&lt;/p&gt;

&lt;h2 id=&#34;recyclebin:6e1e1fe882909f94253528cb85e0a255&#34;&gt;RecycleBin&lt;/h2&gt;

&lt;p&gt;源码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * The RecycleBin facilitates reuse of views across layouts. The RecycleBin has two levels of
     * storage: ActiveViews and ScrapViews. ActiveViews are those views which were onscreen at the
     * start of a layout. By construction, they are displaying current information. At the end of
     * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews are old views that
     * could potentially be used by the adapter to avoid allocating views unnecessarily.
     *
     * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener)
     * @see android.widget.AbsListView.RecyclerListener
     */
    class RecycleBin {
        private RecyclerListener mRecyclerListener;

        /**
         * The position of the first view stored in mActiveViews.
         */
        private int mFirstActivePosition;

        /**
         * Views that were on screen at the start of layout. This array is populated at the start of
         * layout, and at the end of layout all view in mActiveViews are moved to mScrapViews.
         * Views in mActiveViews represent a contiguous range of Views, with position of the first
         * view store in mFirstActivePosition.
         */
        private View[] mActiveViews = new View[0];

        /**
         * Unsorted views that can be used by the adapter as a convert view.
         */
        private ArrayList&amp;lt;View&amp;gt;[] mScrapViews;

        private int mViewTypeCount;

        private ArrayList&amp;lt;View&amp;gt; mCurrentScrap;

        private ArrayList&amp;lt;View&amp;gt; mSkippedScrap;

        private SparseArray&amp;lt;View&amp;gt; mTransientStateViews;
        private LongSparseArray&amp;lt;View&amp;gt; mTransientStateViewsById;
        
        
        ....省略的代码.....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面说的很清楚，RecycleBin的作用是帮助布局中的View的重用，它存储了两种类型的View：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mActiveViews  可以理解为现在显示在屏幕上的View&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mScrapViews&lt;/strong&gt;   我们终于找到了，这就是传回getView中covertView的来源，上面的作用也说的很清楚了，避免不必要的分配Views，优化性能。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ok，已经找到根本原因了，那么ListView又是在什么时候调用的getView方法了，上面说了我们将从fillUp方法看起：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; /**
     * Fills the list from pos up to the top of the list view.
     *
     * @param pos The first position to put in the list
     *
     * @param nextBottom The location where the bottom of the item associated
     *        with pos should be drawn
     *
     * @return The view that is currently selected
     */
    private View fillUp(int pos, int nextBottom) {
        View selectedView = null;

        int end = 0;
        if ((mGroupFlags &amp;amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            end = mListPadding.top;
        }

        while (nextBottom &amp;gt; end &amp;amp;&amp;amp; pos &amp;gt;= 0) {
            // is this the selected item?
            boolean selected = pos == mSelectedPosition;
            View child = makeAndAddView(pos, nextBottom, false, mListPadding.left, selected);
            nextBottom = child.getTop() - mDividerHeight;
            if (selected) {
                selectedView = child;
            }
            pos--;
        }

        mFirstPosition = pos + 1;
        setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);
        return selectedView;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这段代码中，又看到了makeAndAddView，该方法就是把View加到ListView中最终调用的方法，我们来看代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    /**
     * Obtain the view and add it to our list of children. The view can be made
     * fresh, converted from an unused view, or used as is if it was in the
     * recycle bin.
     *
     * @param position Logical position in the list
     * @param y Top or bottom edge of the view to add
     * @param flow If flow is true, align top edge to y. If false, align bottom
     *        edge to y.
     * @param childrenLeft Left edge where children should be positioned
     * @param selected Is this position selected?
     * @return View that was added
     */
    private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
            boolean selected) {
        View child;

        //如果数据没有变化，直接去ActiveView中拿，这是最快的。
        if (!mDataChanged) {
            // Try to use an existing view for this position
            child = mRecycler.getActiveView(position);
            if (child != null) {
                // Found it -- we&#39;re using an existing child
                // This just needs to be positioned
                setupChild(child, position, y, flow, childrenLeft, selected, true);

                return child;
            }
        }

        //如果数据变化了，新建一个View，或则如果可能的话去ScrapView中拿一个缓存。
        // Make a new view for this position, or convert an unused view if possible
        child = obtainView(position, mIsScrap);


        //这个方法负责，把View放到ListView中合适的位置，具体就不看代码了，有兴趣自己去看源码
        // This needs to be positioned and measured
        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

        return child;
    }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们只有接着看obtainView,该方法中就调用了getView方法，注意看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * Get a view and have it show the data associated with the specified
     * position. This is called when we have already discovered that the view is
     * not available for reuse in the recycle bin. The only choices left are
     * converting an old view or making a new one.
     *
     * @param position The position to display
     * @param isScrap Array of at least 1 boolean, the first entry will become true if
     *                the returned view was taken from the scrap heap, false if otherwise.
     *
     * @return A view displaying the data associated with the specified position
     */
    View obtainView(int position, boolean[] isScrap) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &amp;quot;obtainView&amp;quot;);

        isScrap[0] = false;

        //这个瞬时状态的View，看了下说明，大概就是item有动画等效果的，我们不关心这个
        // Check whether we have a transient state view. Attempt to re-bind the
        // data and discard the view if we fail.
        final View transientView = mRecycler.getTransientStateView(position);
        if (transientView != null) {
            final LayoutParams params = (LayoutParams) transientView.getLayoutParams();

            // If the view type hasn&#39;t changed, attempt to re-bind the data.
            if (params.viewType == mAdapter.getItemViewType(position)) {
                final View updatedView = mAdapter.getView(position, transientView, this);

                // If we failed to re-bind the data, scrap the obtained view.
                if (updatedView != transientView) {
                    setItemViewLayoutParams(updatedView, position);
                    mRecycler.addScrapView(updatedView, position);
                }
            }

            // Scrap view implies temporary detachment.
            isScrap[0] = true;
            return transientView;
        }

        //看这里，我们先去缓存中取一个scrapView
        final View scrapView = mRecycler.getScrapView(position);
        
        //看到没，这里调用了getView方法，去初始化我们的covertView，知道covertView怎么来的吧。
        final View child = mAdapter.getView(position, scrapView, this);
        if (scrapView != null) {
        
            //如果不相等，这种情况就是我们covertView为null的情况
            if (child != scrapView) {
                // Failed to re-bind the data, return scrap to the heap.
                mRecycler.addScrapView(scrapView, position);
            } else {
                isScrap[0] = true;
                
                //这个方法没有看到说明，大概就是绘制相关的
                child.dispatchFinishTemporaryDetach();
            }
        }

        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }

        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }

        setItemViewLayoutParams(child, position);

        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityDelegate == null) {
                mAccessibilityDelegate = new ListItemAccessibilityDelegate();
            }
            if (child.getAccessibilityDelegate() == null) {
                child.setAccessibilityDelegate(mAccessibilityDelegate);
            }
        }

        Trace.traceEnd(Trace.TRACE_TAG_VIEW);

        return child;
    }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok，大概就这样，ListView个人觉得他的实现是Android中一个比较经典的东西，如果看懂这个了的话，还可以看touch事件分发，ViewGroup绘制原理，有兴趣的同学可以深入的去看一下源码，绝对受益匪浅.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>谈谈源码中的SparseArray</title>
      <link>http://lorcanluo.github.io/post/%E8%B0%88%E8%B0%88%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84SparseArray/</link>
      <pubDate>Fri, 27 Nov 2015 18:43:17 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/%E8%B0%88%E8%B0%88%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84SparseArray/</guid>
      <description>

&lt;p&gt;在Andorid的源码和第三方库中，偶尔能看到该类，我们先来看一下官方文档的说明如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SparseArray map integers to Objects.  Unlike a normal array of  Objects,there can be gaps in the indices.  It is intended to be more memory efficient than using a HashMap to map Integers to Objects, both because it avoids auto-boxing keys and its data structure doesn&amp;rsquo;t rely on an extra entry object for each mapping.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的意思是SparseArray 用来替代HashMap Int到Object的这种关系。 它设计的目的是为了比HashMap更加节省内存，这是因为：
1. 它避免了键值的自动装箱
2. 他的数据结构不需要依赖额外的对象来完成映射。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that this container keeps its mappings in an array data structure,using a binary search to find keys.  The implementation is not intended to be appropriate for data structures that may contain large numbers of items.  It is generally slower than a traditional HashMap, since lookups require a binary search and adds and removes require inserting and deleting entries in the array.  For containers holding up to hundreds of items,the performance difference is not significant, less than 50%.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面说了，SparseArray通过二分查找键值，这种实现方式不太适合太多的item。通常情况他是比HashMap慢的，但是如果容器只有数百的item，这个性能损失不太重要，不超过50%。&lt;/p&gt;

&lt;p&gt;实际在Android环境中，我们的键值也很少有超过上千的，所以SparseArray我们能在项目中用到的地方还是不少，如果在Android Stuido出现一个黄色警告叫你替换的话，你就可以考虑替换了。因为对于Android 来说，内存往往比较重要一点。&lt;/p&gt;

&lt;h2 id=&#34;稀疏数组:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;稀疏数组&lt;/h2&gt;

&lt;p&gt;下面我们分析SparseArray的实现方式，从字面意思上翻译过来就是稀疏数组，首先我们打开源码看一下SparseArray的结构是怎么样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SparseArray&amp;lt;E&amp;gt; implements Cloneable {
    private static final Object DELETED = new Object();
    private boolean mGarbage = false;

    private int[] mKeys;
    private Object[] mValues;
    private int mSize;
    
    ........我是省略的代码哟..........   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看的出代码中有一个 int[] mKeys 数组， 和一个 Object[] mValues 数组，这两个就是存放键值和对象的地方，mSize是我们存入了多少键值对。下面我们将要用一个非常土的办法来看看这个结构是怎么样的，我们写一段测试代码如下，断点调试。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 SparseArray&amp;lt;Object&amp;gt; sparseArray = new SparseArray&amp;lt;&amp;gt;();
2 sparseArray.put(1, &amp;quot;11&amp;quot;);
3 sparseArray.put(8, &amp;quot;13&amp;quot;);
4 sparseArray.put(4, &amp;quot;12&amp;quot;);
5 sparseArray.put(0, &amp;quot;30&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们执行第二行代码以后：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mKey&lt;/strong&gt;中的结构:    {1,0,0,0,0,0,0,0,0,0,0,0}  后面的0是初始化mKey的长度
&lt;strong&gt;mValues&lt;/strong&gt;中的结构: {&amp;ldquo;11&amp;rdquo;}&lt;br /&gt;
&lt;strong&gt;mSize&lt;/strong&gt;: 1&lt;/p&gt;

&lt;p&gt;我们执行第三行代码以后：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mKey&lt;/strong&gt;中的结构:    {1,8,0,0,0,0,0,0,0,0,0,0}  后面的0是初始化mKey的长度
&lt;strong&gt;mValues&lt;/strong&gt;中的结构: {&amp;ldquo;11&amp;rdquo;,&amp;ldquo;13&amp;rdquo;}&lt;br /&gt;
&lt;strong&gt;mSize&lt;/strong&gt;: 2&lt;/p&gt;

&lt;p&gt;我们执行第三行代码以后：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mKey&lt;/strong&gt;中的结构:    {1,4,8,0,0,0,0,0,0,0,0,0}  后面的0是初始化mKey的长度
&lt;strong&gt;mValues&lt;/strong&gt;中的结构: {&amp;ldquo;11&amp;rdquo;,&amp;ldquo;12&amp;rdquo;,&amp;ldquo;13&amp;rdquo;}&lt;br /&gt;
&lt;strong&gt;mSize&lt;/strong&gt;: 3&lt;/p&gt;

&lt;p&gt;我们执行第三行代码以后：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mKey&lt;/strong&gt;中的结构:    {0,1,4,8,0,0,0,0,0,0,0,0,0}  后面的0是初始化mKey的长度
&lt;strong&gt;mValues&lt;/strong&gt;中的结构: {&amp;ldquo;30&amp;rdquo;,&amp;ldquo;11&amp;rdquo;,&amp;ldquo;12&amp;rdquo;,&amp;ldquo;13&amp;rdquo;}&lt;br /&gt;
&lt;strong&gt;mSize&lt;/strong&gt;: 4&lt;/p&gt;

&lt;p&gt;从以上的结构中我们可以判断出，如果我们想查找一个键值为4的key，那么首先第一步找到key对应在mKey数组中的index，那么对应的value就在对应mValues中的index位置。再仔细观察上面的mKey中的结构，你会发现mKey中的数字是递增的，那么这保证了我们就可以通过二分查找去找到某一个值在mkey中的位置。ok这个结构分析完毕之后，我们接下来看看，增，删，查，找功能。&lt;/p&gt;

&lt;h2 id=&#34;add:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;ADD&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * Adds a mapping from the specified key to the specified value,
     * replacing the previous mapping from the specified key if there
     * was one.
     */
    public void put(int key, E value) {
        //通过二分查找键值
        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

        //如果找到了 就直接替换
        if (i &amp;gt;= 0) {
            mValues[i] = value;
        } else {
            //如果没有找到，这个返回的值就是没有找到的mid+1 那么再取反 正好是当前mKey的存有值      
            //的下一个值，只能说好巧妙~~
            i = ~i;  

            if (i &amp;lt; mSize &amp;amp;&amp;amp; mValues[i] == DELETED) {
                mKeys[i] = key;
                mValues[i] = value;
                return;
            }

            if (mGarbage &amp;amp;&amp;amp; mSize &amp;gt;= mKeys.length) {
                gc();

                // Search again because indices may have changed.
                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
            }

            //GrowingArrayUtils 这个源码看不到，google下源码，就是他会动态增加数组的size,    
            //通过System.arraycopy 实现的，具体自己去google咯
            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
            mSize++;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;delete:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;Delete&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;   /**
     * Removes the mapping from the specified key, if there was any.
     */
    public void delete(int key) {
    
        //还是二分查找
        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

        //找到了删除
        if (i &amp;gt;= 0) {
            if (mValues[i] != DELETED) {
                mValues[i] = DELETED;
                mGarbage = true;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;Find&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * Gets the Object mapped from the specified key, or the specified Object
     * if no such mapping has been made.
     */
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E get(int key, E valueIfKeyNotFound) {
        //还是二分查找
        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

        if (i &amp;lt; 0 || mValues[i] == DELETED) {
            return valueIfKeyNotFound;
        } else {
            return (E) mValues[i];
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了以上的操作，都是通过二分查找来操作的，所以和HashMap相比， 性能还是有所损失的，最后看看GC的操作&lt;/p&gt;

&lt;h2 id=&#34;gc:68a0a5bdd5b5422fc1df9e0944b74246&#34;&gt;GC&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; private void gc() {
        // Log.e(&amp;quot;SparseArray&amp;quot;, &amp;quot;gc start with &amp;quot; + mSize);

        int n = mSize;
        int o = 0;
        int[] keys = mKeys;
        Object[] values = mValues;

        //循环查找 找到了置空
        for (int i = 0; i &amp;lt; n; i++) {
            Object val = values[i];

            if (val != DELETED) {
                if (i != o) {
                    keys[o] = keys[i];
                    values[o] = val;
                    values[i] = null;
                }

                o++;
            }
        }

        mGarbage = false;
        mSize = o;

        // Log.e(&amp;quot;SparseArray&amp;quot;, &amp;quot;gc end with &amp;quot; + mSize);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结一下， 就是SpareArray 比HashMap更节约内存，但是性能不如HashMap，在Android系统这内存似金的年代，我们还是应该想尽各种办法去节约内存的。 SpareArray还有一个兄弟 叫LongSparsArray 实现原理也是一样的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android界面优化</title>
      <link>http://lorcanluo.github.io/post/Android%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 28 Oct 2015 15:52:23 +0800</pubDate>
      
      <guid>http://lorcanluo.github.io/post/Android%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/</guid>
      <description>

&lt;p&gt;工作几年，遇到需要页面优化的地方不少，在刚开始学写代码的时候大多数人只为了方便实现，而很少考虑效率问题，等到发现问题的时候回来修改，就会变得十分麻烦了。&lt;/p&gt;

&lt;p&gt;该文总结了Google Io大会的一个效率方面的培训，和我自己的一些经验。&lt;/p&gt;

&lt;h2 id=&#34;16毫秒原则:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;16毫秒原则&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lorcanluo/myHugoProject/master/myImage/optimizeUi/optimize_16ms.png&#34; alt=&#34;ui screenshot&#34; /&gt;
Android系统每隔&lt;strong&gt;16ms&lt;/strong&gt;发出&lt;strong&gt;VSYNC&lt;/strong&gt;信号，触发对UI进行渲染， 如果每次渲染都成功，这样就能够达到流畅的画面所需要的&lt;strong&gt;60fps&lt;/strong&gt;，为了能够实现&lt;strong&gt;60fps&lt;/strong&gt;，这意味着程序的大多数操作都必须在&lt;strong&gt;16ms&lt;/strong&gt;内完成。如图所示，如果你的操作都是在16ms内完成的，那么你的页面就是流畅的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_16ms2.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看上图，如果你的某个操作花费时间是&lt;strong&gt;24ms&lt;/strong&gt;，系统在得到&lt;strong&gt;VSYNC&lt;/strong&gt;信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在&lt;strong&gt;32ms&lt;/strong&gt;内看到的会是同一帧画面。&lt;/p&gt;

&lt;h2 id=&#34;什么原因会导致丢帧:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;什么原因会导致丢帧？&lt;/h2&gt;

&lt;p&gt;上面说了产生卡顿的原理，但是实际工作中，我们有哪些原因会引起这种问题呢：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;过度绘制：Layout 太复杂，UI重叠太多&lt;/li&gt;
&lt;li&gt;内存问题：GC频繁 内存泄露&lt;/li&gt;
&lt;li&gt;多线程处理不当，互锁产生&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;过度绘制:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;过度绘制&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Overdraw&lt;/strong&gt;(过度绘制) 描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_overdraw.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;调试overdraw的办法:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;调试OverDraw的办法&lt;/h4&gt;

&lt;p&gt;方法1：Android开发者选项中打开&lt;strong&gt;&lt;em&gt;调试GPU过度绘制&lt;/em&gt;&lt;/strong&gt;，页面上就会显示出不同的颜色。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;淡蓝色  表示只有一层 这是最好的情况&lt;/li&gt;
&lt;li&gt;浅绿色  表示有二层覆盖 这也还好&lt;/li&gt;
&lt;li&gt;淡红色  表示三层覆盖 我认为这种情况在实际工作中，还是很常见的&lt;/li&gt;
&lt;li&gt;深红色  表示4层以上的覆盖 这就比较严重了 需要自己研究下布局&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_overdraw2.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;方法二：DDMS 中有一个工具叫作：&lt;strong&gt;Hierarchy View&lt;/strong&gt; 这个工具就可以看出具体的布局了，你可以通过该工具分析具体的布局深度，但是该工具需要root手机，如果你的手机没有root，那么就用模拟器。下图是我的一个截图，大概就是这样子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_hierarchy.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;常用的一些android布局标签:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;常用的一些Android布局标签&lt;/h4&gt;

&lt;p&gt;我们还可以用一些Android提供的布局标签去优化我们的布局，有三个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Mergy&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;ViewStup&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Include&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;mergy:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;Mergy&lt;/h5&gt;

&lt;p&gt;Mergy标签的主要目的就是用来减少层级使用的，具体可以参考&lt;a href=&#34;http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-by.html&#34;&gt;http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-by.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;viewstup:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;ViewStup&lt;/h4&gt;

&lt;p&gt;ViewStup标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用标签，以减少内存使用量，加快渲染速度。具体可以参考&lt;a href=&#34;http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-with.html&#34;&gt;http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-with.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;include:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;Include&lt;/h4&gt;

&lt;p&gt;Include就是可以重用布局，具体对层级没啥优化效果，只是可以减少一部分重复代码。&lt;/p&gt;

&lt;p&gt;我写了Mergy和ViewStup的一个例子放在我的GitHub上，大家可以使用Hierarchy View 去观察布局的变化。 &lt;a href=&#34;https://github.com/lorcanluo/trainingOptimizingUI&#34;&gt;Samples-&amp;gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;内存问题-gc:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;内存问题-GC&lt;/h3&gt;

&lt;p&gt;虽然Android有自动管理内存的机制，但是对内存的不恰当使用仍然容易引起严重的性能问题。&lt;strong&gt;&lt;em&gt;在同一帧里面创建过多的对象是件需要特别引起注意的事情。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同 的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。模型如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_memory.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;为什么gc会引起卡顿了:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;为什么GC会引起卡顿了？&lt;/h4&gt;

&lt;p&gt;除了速度差异之外，执行GC操作的时候，&lt;strong&gt;&lt;em&gt;任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行&lt;/em&gt;&lt;/strong&gt;。
通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。&lt;strong&gt;&lt;em&gt;如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&#34;导致gc频繁的原因:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;导致GC频繁的原因：&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;Memory Churn内存抖动&lt;/strong&gt;，内存抖动是因为大量的对象被创建又在短时间内马上被释放。&lt;/p&gt;

&lt;p&gt;瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加 Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_memory2.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过Android提供的&lt;a href=&#34;https://developer.android.com/tools/performance/memory-monitor/index.html&#34;&gt;Memory Monitor&lt;/a&gt;工具就可以观察到这一现象，大概如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/lorcanluo/myHugoProject/blob/master/myImage/optimizeUi/optimize_memory3.png?raw=true&#34; alt=&#34;ui screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你看到图中的现象那么你就需要注意查看你得代码是否有问题了。&lt;/p&gt;

&lt;h4 id=&#34;内存泄露:a833aff54ae97d9b891a1bf799bf08ba&#34;&gt;内存泄露&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间&lt;/strong&gt;。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。&lt;/p&gt;

&lt;p&gt;Android也提供了工具去分析这些情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DDMS中的 Heap Tool&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Allocation tracker&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你还可以使用&lt;strong&gt;&lt;em&gt;MAT&lt;/em&gt;&lt;/strong&gt;去分析你得代码等等，具体内存分析的问题下一次再来讨论。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>